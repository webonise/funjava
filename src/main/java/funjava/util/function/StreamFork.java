package funjava.util.function;

import funjava.FunJava;

import java.lang.ref.Reference;
import java.lang.ref.WeakReference;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.*;
import java.util.stream.*;

/**
 * {@link java.util.stream.Stream} instances aren't intended to be consumed more than once. But sometimes it is really
 * handy to have two forks. This class implements that capability, however it does this in a somewhat limited way.
 * <p>
 * This class acts as a terminal of an existing stream. It is, however, a lazy terminal. The value that this terminal
 * produces is a stream factory. The generated streams are independent, and may be executed at any time. However, any
 * of
 * the generated streams will trigger values to be generated from upstream. Values generated by the terminated upstream
 * stream are fed into the streams generated by this class.
 * <p>
 * This class needs to be handled with care. There are a few particular concerns to keep in mind:
 * <ul>
 * <li><i>Forked streams will only receive elements generated by the upstream after they were forked.</i> This means
 * that a stream can "miss" some early values if is forked after the upstream begins to be exercised.</li>
 * <li><i>Forked streams will cache values they have not consumed.</i> This means that an upstream which generates
 * very many objects might result in significant memory consumption, unless the generated streams are consuming values
 * efficiently.</li>
 * </ul>
 */
public class StreamFork<A> implements AutoCloseable {

  private final Stream<A> upstreamSource;
  private final Spliterator<A> upstream;
  private final List<WeakReference<Queue<A>>> queueRefs = new CopyOnWriteArrayList<WeakReference<Queue<A>>>();
  private final Queue<Queue<A>> queueQueue;

  /**
   * Creates an instance that terminates the given stream.
   *
   * @param upstream The stream to terminate; never {@code null}
   */
  public StreamFork(Stream<A> upstream) {
    this(upstream, 0);
  }

  /**
   * Creates an instance that terminates the given stream and expects at least {@code forkCount} forks to occur.
   * This constructor is useful for ensuring that no elements are lost by internally pre-forking a certain number of
   * streams before the constructor returns. <strong>Values will be cached until {@link #fork()} has been called
   * {@code forkCount} times.</strong>
   *
   * @param upstream  The stream to terminate; never {@code null}
   * @param forkCount The count of the number of forks to pre-initialize: values less than zero are equivalent to zero
   */
  public StreamFork(Stream<A> upstream, int forkCount) {
    Objects.requireNonNull(upstream, "upstream stream");
    this.upstream = upstream.spliterator();
    this.queueQueue = new ArrayBlockingQueue<Queue<A>>(Math.max(1, forkCount));
    for (int i = 0; i < forkCount; i++) {
      preinitializeJoin();
    }
    this.upstreamSource = upstream;
  }

  private void preinitializeJoin() {
    Queue<A> q = new LinkedBlockingQueue<A>();
    this.queueQueue.add(q);
    this.queueRefs.add(new WeakReference<Queue<A>>(q));
  }


  /**
   * Generates a new stream which will contain all the remaining elements from upstream.
   *
   * @return A fork of upstream; never {@code null}.
   */
  public Stream<A> fork() {
    Queue<A> q = generateQueue();
    Runnable c = this::tryReadUpstream;

    Spliterator source = new Spliterators.AbstractSpliterator<A>(upstream.estimateSize(), upstream.characteristics()) {

      @Override
      public boolean tryAdvance(final Consumer<? super A> action) {
        if (q.isEmpty()) {
          tryReadUpstream();
          if (q.isEmpty()) return false;
        }
        action.accept(q.remove());
        return true;
      }
    };

    return StreamSupport.stream(source, upstreamSource.isParallel());
  }

  private Queue<A> generateQueue() {
    Queue<A> q = queueQueue.poll();
    if (q == null) {
      long upstreamSize = upstream.estimateSize();
      if(upstreamSize < Integer.MAX_VALUE) {
        q = new ArrayBlockingQueue<A>((int)upstreamSize);
      } else {
        q = new LinkedBlockingQueue<>();
      }
      queueRefs.add(new WeakReference<>(q));
    }
    return q;
  }

  /**
   * When this method returns, we have attempted to read an element from upstream. If an element existed, all the
   * queues will have received the element.
   */
  private synchronized void tryReadUpstream() {
    upstream.tryAdvance(a -> {
          for (Reference<Queue<A>> qRef : queueRefs) {
            Queue<A> q = qRef.get();
            if (q == null) {
              FunJava.getExecutor().submit(() -> queueRefs.remove(qRef));
            } else {
              q.add(a);
            }
          }
        }
    );
  }

  /**
   * Forgets about all generated queues and closes the upstream stream.
   */
  @Override
  public void close() {
    queueQueue.clear();
    queueRefs.clear();
    upstreamSource.close();
  }
}
