package funjava.util.function;

import java.util.*;
import java.util.function.*;

public interface FunBiFunction<T, U, R> extends BiFunction<T, U, R> {

  /**
   * Split this bifunction into a function of one argument returning another one-argument function.
   * <p>
   * In short, it makes {@code f:(a,b)->c} into {@code f:(a)->(b->c)}.
   *
   * @return The curried function.
   */
  public default FunFunction<T, FunFunction<U, R>> curry() {
    return (T a) -> (U b) -> this.apply(a, b);
  }

  /**
   * Given a one-argument function that returns another function, convert it into a function taking two arguments.
   * <p>
   * In short, make {@code f:(a)->(b->c)} into {@code f:(a,b)->c}.
   *
   * @param f The function to uncurry; never {@code null}.
   * @return The uncurried function.
   */
  public static <A, B, C> FunBiFunction<A, B, C> uncurry(Function<A, Function<B, C>> f) {
    Objects.requireNonNull(f, "function to curry");
    return (A a, B b) -> {
      Function<B, C> g = f.apply(a);
      Objects.requireNonNull(g, "function generated by applying argument");
      return g.apply(b);
    };
  }


  /**
   * Given a bifunction and a value, partially apply the value to the bifunction.
   *
   * @param a The value to partially apply; may be {@code null}
   * @return A function that is {@code a} partially applied to {@code this}.
   */
  public default FunFunction<U, R> applyPartial(T a) {
    return b -> apply(a, b);
  }


  /**
   * Swap the position of the two arguments.
   *
   * @return The bifunction that swaps the arguments and calls {@code this}.
   */
  public default FunBiFunction<U, T, R> swap() {
    return (a, b) -> apply(b, a);
  }


}
